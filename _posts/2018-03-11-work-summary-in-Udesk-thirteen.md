---
layout: post
title: 最近工作总结(十二)
date:   2018-01-06 16:55:06
categories: Work
image: /assets/images/post.jpg
---

##### redis AOF 重写机制-BGREWRITEAOF
AOF重写并不需要对原有AOF文件进行任何写入和读取，它针对的是数据库中键的当前值。

```
RPUSH list 1 2 3 4    //[1,2,3,4]
RPOP list                    //[1,2,3]
LPOP list            //[2,3]
```

AOF重写，会将上面的三个操作，用一个操作重写到AOF文件中

```
RPUSH list 2 3
```

减少AOF文件中的内容，以达到压缩AOF文件的目的。根据键的类型，使用适当的写入命令来重现键的当前值，这就是AOF重写的实现原理。

redis会开启一个后台子进程进行AOF重写程序。

+ 子进程进行AOF重写时，主进程可以继续处理命令请求；
+ 子进程携带有主进程的数据副本，使用子进程而不是线程，可以避免在锁的情况下，保证数据的安全性。

子进程在进行AOF重写期间，主进程还要继续处理命令请求，而新的命令可能对现有的数据进行修改，这会让当前数据库的数据和重写后的AOF文件中的数据不一致。

为了解决这个问题，redis增加了AOF重写缓存。这个缓存在fork出子进程之后开始启用，Redis主进程在接到新的写命令之后，除了会将这个写命令的内容追加到现有的AOF文件之外，还会追加到这个缓存中：

1、处理命令请求；

2、将写命令追加到现有的AOF文件中；

3、将写命令追加到AOF重写缓存中。

当子进程完成对AOF文件重写之后，它会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：

+ 将AOF重写缓存中的内容全部写入到新的AOF文件中；”执行完毕后，现有AOF文件、新的AOF文件和数据库三者的状态就完全一致了

+ 对新的AOF文件进行改名，覆盖原有的AOF文件。”执行完毕后，程序就完成了新旧两个AOF文件的替换

在整个AOF后台重写过程中，只有最后的“主进程写入命令到AOF缓存”和“对新的AOF文件进行改名，覆盖原有的AOF文件。”这两个步骤会造成主进程阻塞，在其他时候，AOF后台重写都不会对主进程造成阻塞，这将AOF重写对性能造成的影响降到最低。

每次当serverCron（服务器常规操作）函数执行时，它会检查以下条件是否全部满足，如果全部满足的话，就触发自动的AOF重写操作：

1）、没有BGSAVE命令（RDB持久化）/AOF持久化在执行；

2）、没有BGREWRITEAOF在进行；

3）、当前AOF文件大小要大于server.aof_rewrite_min_size（默认为1MB），或者在redis.conf配置了auto-aof-rewrite-min-size大小；

4）、当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比（在配置文件设置了auto-aof-rewrite-percentage参数，不设置默认为100%）



如果前面三个条件都满足，并且当前AOF文件大小比最后一次AOF重写时的大小要大于指定的百分比，那么触发自动AOF重写。
