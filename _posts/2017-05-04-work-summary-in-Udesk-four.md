---
layout: post
title: 最近工作总结(四)
date:   2017-05-04 14:57:06
categories: Work
image: /assets/images/post.jpg
---

##### 在数据库层面建立唯一索引，是最好的防止数据重复的方法，即使是在高并发的情况下
在Rails model层使用validates　方法进行唯一性的验证逻辑，比如:

```ruby
validates :content, uniqueness: { scope: [:company_id], message: "%{value}已经使用" }
```
然而，当高并发时,两个请求相差0.4s，这个在model层的验证并不是真正原子性的，是的这层验证失效。
如果能在数据库建立唯一索引[company_id, content]，这样，对高并发情况，也能支持验证，防止数据库产生脏数据。

##### union 出现在request body中时,会被阿里高防识别为可疑攻击而返回405。
比如 MySQL 的union注入攻击

##### https域名中有http的请求
https的域名下发起http的请求，浏览器会认为发起了不安全的请求而报错。
将该请求也使用https
一般https域名的地址，当使用http协议访问时，Nginx只要做了http到https的重定向，就能重定向到https协议下

##### Don't forget Sidekiq get the json not the hash params
当传递hash 参数到Sidekiq 中的时候，Sidekiq 中间会转为json.　再转回hash
所以，hash = {name: 'cary'} 到Sidekiq 中就变为　hash = {"name" => 'cary'}
hash[:name] => nil
hash["name"] => cary

##### 在同一个方法中，平级的操作，将复杂的更可能报错的操作放在后面

```ruby

def operation_data

  process_easy

  process

  process_hard

end

```
在同一个方法中，平级的操作，将复杂的更可能报错的操作放在后面,　这样可以避免当process_hard操作报错中止代码往下运行，而导致process_easy的操作没有执行。如果这些都是数据库的操作，则会导致有数据没有被操作成功。这里并没有想要用事务操作，因为其中的报错并不需要回滚，可以容忍报错，但希望见得数据库操作不要被这报错影响。

#####　binding.pry 别放在方法的最后，这样，如果方法有返回值，则不会正常返回，而返回的是nil

##### RestClient timeout
RestClient 其实有两种timeout。　read_timeout　和　open_timeout。　如果传的参数是timeout，则这两个timeout的值都是传递过来的参数
timeout的值。也可以分开进行传递，只传read_timeout　或　open_timeout

##### MongoDB 权威指南 小记录

范式化和反范式化。范式化是将数据分散到多个不同的集合，不同的集合之间可以互相引用数据。如果需要修改这块数据，只需要修改保存这块数据的那一个文档就行了。但是，MongoDB没有提供连接(join)工具，所以在不同集合之间执行连接查询要进行多次查询。
反范式化与范式化相反：将每个文档所需要的数据都嵌入在文档内部。每个文档都拥有自己的数据副本，而不是所有文档共同引用同一个数据副本。这意味着，如果信息发生了变化，那么所有相关文档都需要进行更新，但是在执行查询时，只需要一次查询，就可以得到所有数据。
范式化利于更新，而需要做更多的查询，比如join或多次查询。反范式化利于查询，一次查询就得到所有数据，但是不利于更新。数据同步更困难。

许多人混淆复制和分片的概念，复制是让多台服务器都有统一的数据副本，每一台服务器都是其他服务器的镜像，而每一个分片都有其他分片拥有不同的数据子集。 进行分片一般需要有定义分片键，分片键需要建立索引。需要根据分片键定制一个路由机制。路由机制可以简单的说，就是根据一定的规则，将这个文档存入某个分片中。但一个查询来时，按照路由机制，去对应的分片中得到这个文档。这个和ES的分片机制是相似的。简单的路由机制，比如取ID这种唯一字段值得hash值。MongoDB中需要建立配置服务器，配置服务器和普通的MongoDB服务器一样，但是它相当于集群的大脑，保存着集群和分片的元数据，即各个分片包含哪些数据的信息。一般建立三台独立的物理机器。配置服务器中存的是数据的分布表，而不是真实的文档数据，所以，相对来说数据量不会很大。可以认为，配置服务器就是存储着“路由机制”。MongoDB中，对分片还进行“块（chunk）机制”的存储方案。一个块只存在于一个分片上，所以MongoDB用一个比较小的表就能够维护块和分片的映射。当一个块增长到特定大小时，MongoDB会自动将其拆分为两个较小的块。一个文档属于且只属于一个块。
