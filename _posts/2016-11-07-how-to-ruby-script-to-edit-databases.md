---
layout: post
title: 如何更安全、稳定的写Ruby脚本操作线上数据库的表
date:   2016-11-07 16:15:06
categories: rails
image: /assets/images/post.jpg
---

描述：某个功能需要为数据库增加相关数据。大概逻辑是：根据表F(100w条记录)，根据某些条件往Fm表中插入数据，所以，至少要插入100w条记录。
然后将F表中满足筛选条件的status字段进行更改(大概有80w条记录)。

结果：需要超过一个小时才将整个脚本跑完

反思：可以更安全、稳定的写Ruby脚本操作线上数据库的表吗？

一、思考脚本是否可以在项目升级前运行
  如果脚本可以在项目升级前运行，则可以在一定程度上更早的发现问题，以做出对正式升级时的预防。比如，操作新的表，或新的字段。这种情况是完全可以提早运行脚本的

二、是否有长时间锁表操作
  警惕长时间锁表的操作。举个例子：比如用update_all 或 批量插入在一定程度上可以更快的运行sql，但是，这些操作会锁表。对于线上的数据库，锁表操作会影响到线上用户的使用。
  让用户感知到系统的延迟。所以，不使用这种批量操作，排除锁表操作，使用粒度小的create，update，destroy操作。虽然，总的执行时间会更长，但是，这样就不会锁表长时间占用数据库的某个表而影响用户的使用
  如果真的无法避免长时间锁表的操作，就需要在后半夜大家睡觉的时候跑脚本了

三、捕获异常错误
  使用异常，捕获异常错误，将异常打印出来。或者可以在全局新建一个数组，然后将某次异常的操作中相关记录的id存入数组中，最后打印出来，就可以知道在执行过程中哪个记录是有问题的，可以很方便的追踪错误，后续就可以
  很方便的进行验证和纠错了

四、让脚本可以重复运行
  尽量让脚本可以重复运行。即使加入额外的find查询。或者捕获异常，而不是让异常中断操作。不要使用清空数据库的方式，因为这样需要从0条记录开始跑，所需要的时间更长

五、使用find_each 或 find_in_batches
  Don't use the each method for Model。很有可能会爆内存。使用find_each 或 find_in_batches 分批次的进行查询循环操作。注意，find_in_batches得到的是对象数组

六、使用gem 'ruby-progressbar' 愉快的展示执行进度
  在Gemfile中假如 gem 'ruby-progressbar', require: false。 然后在脚本文件中  require 'ruby-progressbar' 进行使用。可以很方便的展示脚本执行的百分比和进度。等会会具体的演示下操作和某个坑
