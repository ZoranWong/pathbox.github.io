---
layout: post
title: 在Web application 中基本的安全防范小结
date:   2017-05-22 18:00:06
categories: Web
image: /assets/images/post.jpg
---

##### CSRF攻击

CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。

> 那么CSRF到底能够干嘛呢？你可以这样简单的理解：攻击者可以盗用你的登陆信息，以你的身份模拟发送各种请求。攻击者只要借助少许的社会工程学的诡计，例如通过QQ等聊天软件发送的链接(有些还伪装成短域名，用户无法分辨)，攻击者就能迫使Web应用的用户去执行攻击者预设的操作。例如，当用户登录网络银行去查看其存款余额，在他没有退出时，就点击了一个QQ好友发来的链接，那么该用户银行帐户中的资金就有可能被转移到攻击者指定的帐户中。

CSRF攻击示意图：

![CSRF攻击示意图]( /assets/images/web-safe/csrf.png "Optional title")

CSRF攻击步骤：

1. 登入正常的网站A,并在本地保存了Cookie
2. 在不退出A的情况下,访问了危险网站B

> CSRF攻击主要是因为Web的隐式身份验证机制，Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。

预防：

>1、正确使用GET,POST和Cookie；

>2、在非GET请求中增加伪随机数, 比如随机token；

```go
生成随机数token

h := md5.New()
io.WriteString(h, strconv.FormatInt(crutime, 10))
io.WriteString(h, "ganraomaxxxxxxxxx")
token := fmt.Sprintf("%x", h.Sum(nil))
t, _ := template.ParseFiles("login.gtpl")
t.Execute(w, token)

输出token

<input type="hidden" name="token" value="{{.}}">

验证token

r.ParseForm()
	token := r.Form.Get("token")
	if token != "" {
		//验证token的合法性
	} else {
		//不存在token报错
	}
```

##### 输入验证

过滤用户输入数据，验证数据的合法性，是一个重要的过程。能够在一定程度上，避免恶意数据在程序中被误用。

三个步骤：

>1、识别数据，搞清楚需要过滤的数据来自于哪里

>2、过滤数据，弄明白我们需要什么样的数据

>3、区分已过滤及被污染数据，如果存在攻击数据那么保证过滤之后可以让我们使用更安全的数据

输入数据来自哪里？

1. 表单提交时的参数

2. 接口传递的json参数

3. 参数在url中

4. 参数在http 的Header中

进行验证。验证数据的有效性，可以简单的验证，也可以根据自己的规则而验证。

在`<Grape>`框架中，在controller　层做了验证的DSL语法的验证。`<Rails>`的框架，还可以在model层做验证。

这里建议，如果可以在controller 做验证，最好先做，再继续在model层做相关验证。通过两重的验证，基本可以保证数据的有效性。















参考连接：　https://github.com/astaxie/build-web-application-with-golang　
